# run info

This is the expanded run view, with complete information about the run.

1. Reproducability provenance, all the information needed to re-do each job manually. Link to proven dashboard for more detailed provenance data.
2. The current status of the run (queued, running (elapsed time), completed, failed, error)
3. File output of the run, i.e. files generated by the run. Text files can be examined, images can be viewed, netcdf can be opened in the vis manager.
4. Console output for the run.
5. Meta-data about the run, who started the run, which tempalate it came from, when it started/stopped, what the elapsed time was.
6. Share button to give others users the ability to see the run information.
7. The option to start/stop the run.

### API calls

Get run info, gets the information about a specific run
```
get_run_info = (run_id) =>
    return {
        run_name: (str),
        run_id: (int),
        status: (RunStatus),
        jobs: [{
            JobType: (RunStatus)
        }],
        run_time: (Datetime),
        provenance_link: (str),
        run_script: (str),
        file_output: (list: str),
        console_output: (str),
        metadata: (dict)
    }
```

Start the run
```
start_run = (run_id) => 
    run = Runs.find(run_id)
    if run_is_valid(run):
        start_run(run)
        return True
    else:
        return False
```

Stop a run
```
stop_run = (run_id) =>
    run = Runs.find(run_id)
    if user.has_access(run) and run.is_running():
        stop_run(run_id)
        return True
    else:
        return False
```

Share run with other users
```
share_run = (run_id, new_user) =>
    run = Runs.find(id=run_id)
    run.allowed_users.append(new_user)
```

Get all users
``` 
get_user_list = () =>
    return [user for user in Users.all()]
```

Get all user groups
```
get_user_groups = () =>
    return [group for group in Groups.all()]
```

Create user group
```
create_user_group = (user) =>
    Groups.new(user_list=user).save()
```

Add user to group
```
user_group_add = (user, group_id) => 
    group = Group.find(group_id)
    group.user_list.appen(user)
```

### Websocket requests

Run status change, a run status has changed, which needs to be updated for the user
```
server -> client
run_status_change = (run, status) => 
    index = run_list.find(fun)
    run_list[index].status = status
```